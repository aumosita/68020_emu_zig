# 68000 vs 68020 - 주요 차이점 및 수정 필요 사항

## 1. 메모리 주소 공간

### 68000
- **24비트 주소 버스** (16MB 주소 공간)
- 상위 8비트는 무시됨
- 실제 접근 가능: 0x000000 ~ 0xFFFFFF

### 68020
- **32비트 주소 버스** (4GB 주소 공간)
- 전체 32비트 주소 사용
- 실제 접근 가능: 0x00000000 ~ 0xFFFFFFFF

### 현재 구현 상태
```zig
// memory.zig - 현재는 68000 방식
pub fn read8(self: *const Memory, addr: u32) !u8 {
    const effective_addr = addr & 0xFFFFFF; // ❌ 24-bit mask (68000)
    // ...
}
```

### 수정 필요
✅ **메모리 주소를 32비트 전체로 확장**
- `addr & 0xFFFFFF` → `addr` (마스킹 제거)
- 메모리 크기 4GB까지 지원 (실용적으로는 설정 가능)

---

## 2. 데이터 정렬 (Alignment)

### 68000
- **엄격한 정렬 요구**
  - Word (16비트): 짝수 주소에만 접근 가능
  - Long (32비트): 짝수 주소에만 접근 가능
- 홀수 주소에 Word/Long 접근 시 **Address Error Exception** 발생

### 68020
- **정렬되지 않은 접근 허용**
  - 모든 주소에서 Word/Long 접근 가능
  - 홀수 주소 접근 시 성능 페널티만 존재 (예외 없음)
  - 하드웨어가 자동으로 여러 사이클에 걸쳐 처리

### 현재 구현 상태
```zig
// memory.zig - 현재는 정렬 체크 없음
pub fn read16(self: *const Memory, addr: u32) !u16 {
    // ❌ 정렬 체크 없음 (68020처럼 작동 중)
}
```

### 수정 필요
⚠️ **선택적 68000 호환 모드 추가**
```zig
pub const MemoryConfig = struct {
    size: u32 = 16 * 1024 * 1024,
    enforce_alignment: bool = false, // true면 68000 모드
};

pub fn read16(self: *const Memory, addr: u32) !u16 {
    if (self.enforce_alignment and (addr & 1) != 0) {
        return error.AddressError; // 68000 모드
    }
    // 정상 읽기
}
```

---

## 3. 명령어 캐시 (Instruction Cache)

### 68000
- **캐시 없음**
- 모든 명령어를 직접 메모리에서 페치

### 68020
- **256바이트 온칩 명령어 캐시**
- 캐시 제어 레지스터 (CACR)
- 캐시 활성화/비활성화, 클리어 명령어

### 현재 구현 상태
❌ 캐시 미구현

### 수정 필요
✅ **명령어 캐시 시뮬레이션 추가** (선택적, 성능 에뮬레이션용)
```zig
pub const M68k = struct {
    // 기존 필드...
    cache: ?InstructionCache, // 68020 모드에서만 활성화
};

pub const InstructionCache = struct {
    enabled: bool,
    data: [256]u8, // 256바이트 캐시
    tags: [64]u32, // 캐시 라인 태그 (4바이트 라인 가정)
    // ...
};
```

---

## 4. 새로운 어드레싱 모드

### 68000 어드레싱 모드 (8가지)
1. 데이터 레지스터 직접 (Dn)
2. 주소 레지스터 직접 (An)
3. 주소 간접 ((An))
4. 후증가 ((An)+)
5. 전감소 (-(An))
6. 변위 (d16(An))
7. 즉시값 (#imm)
8. 절대 (xxx.W/L)

### 68020 추가 모드 (5가지)
9. **인덱스 + 변위**: `(d8, An, Xn.SIZE*SCALE)`
   - Xn: 인덱스 레지스터 (Dn 또는 An)
   - SIZE: .W 또는 .L
   - SCALE: 1, 2, 4, 8
   
10. **메모리 간접 + 후증가**: `([bd, An], Xn, od)`
11. **메모리 간접 + 전인덱스**: `([bd, An, Xn], od)`
12. **PC 상대 + 인덱스**: `(d8, PC, Xn.SIZE*SCALE)`
13. **메모리 간접 + PC 상대**

### 현재 구현 상태
❌ 68020 확장 모드 미구현

### 수정 필요
✅ **68020 어드레싱 모드 추가**
- 디코더에서 확장 워드 처리
- 스케일 팩터 지원 (×1, ×2, ×4, ×8)
- 메모리 간접 처리

---

## 5. 새로운 데이터 타입

### 68000
- Byte (8비트)
- Word (16비트)
- Long (32비트)

### 68020 추가
- **Packed BCD** (압축 BCD)
- **비트 필드** (임의 길이 비트 필드, 1~32비트)

### 수정 필요
✅ **비트 필드 연산 지원**
```zig
pub const DataSize = enum {
    Byte,
    Word,
    Long,
    BitField, // 68020
};
```

---

## 6. 새로운 명령어

### 68020 전용 명령어
1. **EXTB.L Dn** - Byte → Long 부호 확장
2. **비트 필드 연산** (8개)
   - BFCHG, BFCLR, BFEXTS, BFEXTU
   - BFFFO, BFINS, BFSET, BFTST
3. **멀티프로세서 지원**
   - CAS, CAS2 (Compare And Swap)
   - TAS (Test And Set) - 68000에도 있지만 68020에서 개선
4. **패킹/언패킹**
   - PACK, UNPK
5. **동적 브레이크포인트**
   - BKPT #n
6. **코프로세서 인터페이스**
   - cpGEN, cpScc, cpDBcc, cpTRAPcc 등

### 수정 필요
✅ **EXTB.L 구현**
✅ **비트 필드 명령어 구현** (TODO.md 참조)
✅ **CAS/CAS2 구현**

---

## 7. 슈퍼바이저 모드 & 예외 처리

### 68000
- **예외 벡터 테이블** (0x000000 ~ 0x0003FF, 256개 벡터)
- 기본 예외: Reset, Bus Error, Address Error, Illegal Instruction 등

### 68020
- **확장 예외 벡터**
- **VBR (Vector Base Register)** - 벡터 테이블 베이스 주소 설정 가능
  - 68000: 항상 0x000000 고정
  - 68020: VBR로 임의 주소 설정 가능

### 현재 구현 상태
```zig
pub const M68k = struct {
    // ...
    sr: u16, // ✅ Status Register 존재
    // ❌ VBR 없음
};
```

### 수정 필요
✅ **VBR 레지스터 추가**
```zig
pub const M68k = struct {
    // 기존 필드...
    vbr: u32, // Vector Base Register (68020)
};

// MOVEC 명령어로 VBR 읽기/쓰기
```

---

## 8. 성능 개선

### 68000
- **16비트 외부 데이터 버스**
- Long 읽기 = 2 사이클 (2번 읽기)

### 68020
- **32비트 외부 데이터 버스**
- Long 읽기 = 1 사이클 (1번 읽기)
- 동적 버스 사이징 (16비트 주변장치와도 통신 가능)

### 수정 필요
✅ **사이클 카운팅 조정**
- Long 연산 사이클 수 감소
- 명령어별 정확한 사이클 수 반영

---

## 9. 코프로세서 인터페이스

### 68000
- 코프로세서 지원 없음

### 68020
- **68881/68882 FPU 인터페이스**
- **68851 PMMU 인터페이스**
- 코프로세서 명령어: cpGEN, cpScc, cpDBcc 등

### 수정 필요
⚠️ **선택적 구현** (FPU/PMMU는 별도 칩)
- 코프로세서 인터페이스 스텁
- 실제 FPU/PMMU는 플러그인으로 분리

---

## 10. MMU (Memory Management Unit)

### 68000
- MMU 없음 (물리 주소만)

### 68020
- **외부 68851 PMMU 지원**
- 가상 메모리, 페이지 테이블, 보호 모드

### 수정 필요
⚠️ **선택적 구현** (고급 기능)
- MMU 시뮬레이션은 Phase 3-4로 연기

---

## 우선순위별 수정 계획

### 🔴 Phase 1: 필수 68020 기능 (즉시 수정)
1. ✅ **32비트 주소 공간** - 메모리 마스킹 제거
2. ✅ **VBR 레지스터 추가**
3. ✅ **EXTB.L 명령어 구현**
4. ✅ **선택적 정렬 체크** (68000 호환 모드)

### 🟡 Phase 2: 중요 68020 기능
5. ✅ **68020 어드레싱 모드** (스케일 팩터 등)
6. ✅ **비트 필드 명령어** (BFCHG, BFSET 등)
7. ✅ **CAS/CAS2** (원자적 연산)
8. ✅ **PACK/UNPK**

### 🟢 Phase 3: 고급 68020 기능
9. ✅ **명령어 캐시 시뮬레이션**
10. ✅ **코프로세서 인터페이스 스텁**
11. ✅ **정확한 사이클 카운팅**

### 🔵 Phase 4: 선택적 기능
12. ⚠️ **68851 PMMU 시뮬레이션** (가상 메모리)
13. ⚠️ **68881/68882 FPU 시뮬레이션** (부동소수점)

---

## 수정 필요한 파일 목록

1. **memory.zig**
   - [ ] 24비트 마스킹 제거 → 32비트 주소
   - [ ] 선택적 정렬 체크 추가

2. **cpu.zig**
   - [ ] VBR 레지스터 추가
   - [ ] 캐시 구조체 추가 (선택적)

3. **decoder.zig**
   - [ ] 68020 확장 어드레싱 모드 디코딩
   - [ ] 비트 필드 명령어 디코딩
   - [ ] EXTB, CAS, PACK/UNPK 디코딩

4. **executor.zig**
   - [ ] EXTB.L 구현
   - [ ] 비트 필드 연산 구현
   - [ ] CAS/CAS2 구현
   - [ ] PACK/UNPK 구현
   - [ ] MOVEC (VBR 읽기/쓰기) 구현

5. **docs/**
   - [ ] 68020 차이점 문서화
   - [ ] 새 명령어 참조 업데이트

---

## 결론

현재 에뮬레이터는 **68000 기반**이며, 다음 수정으로 **진정한 68020 에뮬레이터**가 됩니다:

**최소 필수 수정** (Phase 1):
- 32비트 주소 공간
- VBR 레지스터
- EXTB.L
- 선택적 정렬 모드

**완전한 68020** (Phase 1-2):
- 위 + 68020 어드레싱 모드
- 위 + 비트 필드 명령어
- 위 + CAS/PACK 등

**프로덕션급 68020** (Phase 1-3):
- 위 + 명령어 캐시
- 위 + 정확한 사이클 카운팅
- 위 + 코프로세서 인터페이스
